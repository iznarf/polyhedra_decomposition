

#include "conforming_insertion.h"
#include <CGAL/Segment_3.h>
#include <CGAL/Segment_2.h>
#include <CGAL/intersections.h>
#include <CGAL/Object.h>
#include <algorithm>
#include <limits>
#include <optional>
#include <variant>
#include <vector>
#include <iostream>
#include <unordered_map>

namespace df { namespace reg {

using K   = df::K;
using P2  = df::P2;
using P3  = df::P3;
using Tri = df::Tri2;
using Seg3 = CGAL::Segment_3<K>;
using Seg2 = CGAL::Segment_2<K>;



static inline P3 lift(const P2& p) {
    return P3(p.x(), p.y(), p.x()*p.x() + p.y()*p.y());
}


bool is_insertion_conforming(df::vertex_id id,
                             const df::InputData& D)
{
    const Tri& current = D.tri_current;
    const Tri& lower   = D.tri_lower;

    // 2D position of the vertex to be inserted
    const P2& d2 = D.points2d[id];
    P3        d3 = lift(d2);

    // locate in current triangulation
    Tri::Locate_type lt;
    int li; // index used if point lies on an edge
    Tri::Face_handle fh = current.locate(d2, lt, li);

    if (lt != Tri::FACE) {
        std::cout << "[conform] WARNING: insertion point is not inside a face, cannot check conforming\n";
        return false;
    }

    // face containing the point to be inserted
    auto va = fh->vertex(0);
    auto vb = fh->vertex(1);
    auto vc = fh->vertex(2);


    df::vertex_id ia = va->info();
    df::vertex_id ib = vb->info();
    df::vertex_id ic = vc->info();


    const P2& a2 = va->point();
    const P2& b2 = vb->point();
    const P2& c2 = vc->point();

    // fast path: are (a,d), (b,d), (c,d) already in the lower triangulation?
    bool ad_in_lower = false;
    bool bd_in_lower = false;
    bool cd_in_lower = false;

    for (auto e = lower.finite_edges_begin();
         e != lower.finite_edges_end(); ++e)
    {
        auto f  = e->first;
        int  ei = e->second;

        auto vu = f->vertex(lower.cw(ei));
        auto vv = f->vertex(lower.ccw(ei));

        df::vertex_id u = vu->info();
        df::vertex_id v = vv->info();

        if ((u == ia && v == id) || (u == id && v == ia))
            ad_in_lower = true;
        if ((u == ib && v == id) || (u == id && v == ib))
            bd_in_lower = true;
        if ((u == ic && v == id) || (u == id && v == ic))
            cd_in_lower = true;
    }

    if (ad_in_lower && bd_in_lower && cd_in_lower) {
        std::cout << "[conform] all three edges (" << ia << "," << id << "), ("
                  << ib << "," << id << "), (" << ic << "," << id
                  << ") are already in lower triangulation -> insertion is conforming\n";
        return true;
    }
return false;
}
}}

    






#include "conforming_insertion.h"
#include <CGAL/Segment_3.h>
#include <CGAL/Segment_2.h>
#include <CGAL/intersections.h>
#include <CGAL/Object.h>
#include <algorithm>
#include <limits>
#include <optional>
#include <variant>
#include <vector>
#include <iostream>
#include <unordered_map>

namespace df { namespace reg {

using K   = df::K;
using P2  = df::P2;
using P3  = df::P3;
using Tri = df::Tri2;
using Seg3 = CGAL::Segment_3<K>;
using Seg2 = CGAL::Segment_2<K>;



static inline P3 lift(const P2& p) {
    return P3(p.x(), p.y(), p.x()*p.x() + p.y()*p.y());
}


bool is_insertion_conforming(df::vertex_id id,
                             const df::InputData& D)
{
    const Tri& current = D.tri_current;
    const Tri& lower   = D.tri_lower;

    // 2D position of the vertex to be inserted
    const P2& d2 = D.points2d[id];
    P3        d3 = lift(d2);

    // locate in current triangulation
    Tri::Locate_type lt;
    int li; // index used if point lies on an edge
    Tri::Face_handle fh = current.locate(d2, lt, li);

    if (lt != Tri::FACE) {
        std::cout << "[conform] WARNING: insertion point is not inside a face, cannot check conforming\n";
        return false;
    }

    // face containing the point to be inserted
    auto va = fh->vertex(0);
    auto vb = fh->vertex(1);
    auto vc = fh->vertex(2);


    df::vertex_id ia = va->info();
    df::vertex_id ib = vb->info();
    df::vertex_id ic = vc->info();

      if (id == 5){
        // print ia, ib, ic
        std::cout << "[conform] Insertion check for vertex id " << id << " in face ("
                  << ia << "," << ib << "," << ic << ")\n";
    }


    const P2& a2 = va->point();
    const P2& b2 = vb->point();
    const P2& c2 = vc->point();

    // fast path: are (a,d), (b,d), (c,d) already in the lower triangulation?
    bool ad_in_lower = false;
    bool bd_in_lower = false;
    bool cd_in_lower = false;

    for (auto e = lower.finite_edges_begin();
         e != lower.finite_edges_end(); ++e)
    {
        auto f  = e->first;
        int  ei = e->second;

        auto vu = f->vertex(lower.cw(ei));
        auto vv = f->vertex(lower.ccw(ei));

        df::vertex_id u = vu->info();
        df::vertex_id v = vv->info();

        if ((u == ia && v == id) || (u == id && v == ia))
            ad_in_lower = true;
        if ((u == ib && v == id) || (u == id && v == ib))
            bd_in_lower = true;
        if ((u == ic && v == id) || (u == id && v == ic))
            cd_in_lower = true;
    }

    if (ad_in_lower && bd_in_lower && cd_in_lower) {
        std::cout << "[conform] all three edges (" << ia << "," << id << "), ("
                  << ib << "," << id << "), (" << ic << "," << id
                  << ") are already in lower triangulation -> insertion is conforming\n";
        return true;
    }

    

    // lift the triangle vertices
    P3 a3 = lift(a2);
    P3 b3 = lift(b2);
    P3 c3 = lift(c2);

    Seg2 edge_ad_2d(a2, d2);
    Seg2 edge_bd_2d(b2, d2);
    Seg2 edge_cd_2d(c2, d2);

    // ---- edge (a,d) ----
    for (auto e = lower.finite_edges_begin();
         e != lower.finite_edges_end(); ++e)
    {
        auto f  = e->first;
        int  ei = e->second;

        auto vu = f->vertex(lower.cw(ei));
        auto vv = f->vertex(lower.ccw(ei));

        df::vertex_id u = vu->info();
        df::vertex_id v = vv->info();

        // skip edges that are incident to d or incident to a ("intersection" at endpoint)
        if (u == ia || u == id || v == ia || v == id) continue;

        P2 u2 = vu->point();
        P2 v2 = vv->point();

        Seg2 edge_uv_2d(u2, v2);

        // cheap 2D filter: if segments don't even intersect in 2D, ignore
        if (!CGAL::do_intersect(edge_ad_2d, edge_uv_2d)) continue;

        // full 3D test
        P3 u3 = lift(u2);
        P3 v3 = lift(v2);

        Seg3 seg_uv_3d(u3, v3);
        Seg3 seg_ad_3d(a3, d3);

        // if they intersect in 3D, reject immediately
        if (CGAL::do_intersect(seg_ad_3d, seg_uv_3d)) {
            std::cout << "[conform] WARNING: inserting vertex " << id
                      << " is non-conforming: 3D intersection on edge ("
                      << ia << "," << id << ") vs lower edge ("
                      << u << "," << v << ")\n";
            return false;
        }

        // if they do not intersect, then do height/orientation test
        auto o2d = CGAL::orientation(a2, d2, u2); // >0: u left of a->d, <0: right
        if (o2d == CGAL::NEGATIVE) {
            std::swap(u2, v2);
            std::swap(u3, v3);
        }

        auto o3d = CGAL::orientation(a3, d3, u3, v3);
        // interpret: if (a,d) is "below" (u,v), insertion is non-conforming
        if (o3d == CGAL::POSITIVE) {
            std::cout << "[conform] WARNING: inserting vertex with global id "
                      << id << " is non-conforming (edge (a,d))\n";
            return false;
        }
    }

    // ---- edge (b,d) ----
    for (auto e = lower.finite_edges_begin();
         e != lower.finite_edges_end(); ++e)
    {
        auto f  = e->first;
        int  ei = e->second;

        auto vu = f->vertex(lower.cw(ei));
        auto vv = f->vertex(lower.ccw(ei));

        df::vertex_id u = vu->info();
        df::vertex_id v = vv->info();


        // skip edges that are incident to d or incident to b
        if (u == ib || u == id || v == ib || v == id) continue;

        P2 u2 = vu->point();
        P2 v2 = vv->point();

        Seg2 edge_uv_2d(u2, v2);

        if (!CGAL::do_intersect(edge_bd_2d, edge_uv_2d)) continue;

        P3 u3 = lift(u2);
        P3 v3 = lift(v2);

        Seg3 seg_uv_3d(u3, v3);
        Seg3 seg_bd_3d(b3, d3);

        if (CGAL::do_intersect(seg_bd_3d, seg_uv_3d)) {
            std::cout << "[conform] WARNING: inserting vertex " << id
                      << " is non-conforming: 3D intersection on edge ("
                      << ib << "," << id << ") vs lower edge ("
                      << u << "," << v << ")\n";
            return false;
        }

        auto o2d = CGAL::orientation(b2, d2, u2);
        if (o2d == CGAL::NEGATIVE) {
            std::swap(u2, v2);
            std::swap(u3, v3);
        }

        auto o3d = CGAL::orientation(b3, d3, u3, v3);
        if (o3d == CGAL::POSITIVE) {
            std::cout << "[conform] WARNING: inserting vertex with global id "
                      << id << " is non-conforming (edge (b,d))\n";
            // print vertex ids (b,d) and (u,v)
            std::cout << "  (b,d) = (" << ib << "," << id << ")\n";
            std::cout << "  (u,v) = (" << u << "," << v << ")\n";
            return false;
        }
    }

    // ---- edge (c,d) ----
    for (auto e = lower.finite_edges_begin();
         e != lower.finite_edges_end(); ++e)
    {
        auto f  = e->first;
        int  ei = e->second;

        auto vu = f->vertex(lower.cw(ei));
        auto vv = f->vertex(lower.ccw(ei));

        df::vertex_id u = vu->info();
        df::vertex_id v = vv->info();

        // skip edges that are incident to d or incident to c
        if (u == ic || u == id || v == ic || v == id) continue;

        P2 u2 = vu->point();
        P2 v2 = vv->point();

        Seg2 edge_uv_2d(u2, v2);

        if (!CGAL::do_intersect(edge_cd_2d, edge_uv_2d)) continue;

        P3 u3 = lift(u2);
        P3 v3 = lift(v2);

        Seg3 seg_uv_3d(u3, v3);
        Seg3 seg_cd_3d(c3, d3);

        if (CGAL::do_intersect(seg_cd_3d, seg_uv_3d)) {
            std::cout << "[conform] WARNING: inserting vertex " << id
                      << " is non-conforming: 3D intersection on edge ("
                      << ic << "," << id << ") vs lower edge ("
                      << u << "," << v << ")\n";
            return false;
        }

        auto o2d = CGAL::orientation(c2, d2, u2);
        if (o2d == CGAL::NEGATIVE) {
            std::swap(u2, v2);
            std::swap(u3, v3);
        }

        auto o3d = CGAL::orientation(c3, d3, u3, v3);
        if (o3d == CGAL::POSITIVE) {
            std::cout << "[conform] WARNING: inserting vertex with global id "
                      << id << " is non-conforming (edge (c,d))\n";
            return false;
        }
    }

    std::cout << "[conform] insertion of vertex with global id " << id
              << " is conforming\n";
    return true;
}
}}


























    
#include <polyscope/polyscope.h>

#include <iostream>
#include <iomanip>
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <array>
#include <cstdint>
#include <sstream>

#include "input.h"
#include "visualization.h"
#include "edge_flip_loop.h"
#include "insertion.h"
#include "flip.h"
#include "conforming_insertion.h"
#include "debug.h"
#include "geometry_utils.h"
#include "replay.h"

// replay state
static int replay_step = 0;
static bool replay_initialized = false;



int main() {
    polyscope::init();

    // number of vertices in triangulation
    int n_points = 19;
    // random seed to start point generation
    unsigned seed0 = 42;

    df::InputData in = df::make_random_valid_input(n_points, seed0);

    // current setup: we do not sort the to be inserted vertices by height 
    // we do a conforming insertion check 

    // these are valid inputs where the algorithm works:
    //df::InputData in = daf::make_random_input(37, 4458);
    //df::InputData in = df::make_random_input(19, 42);
    //df::InputData in = df::make_random_input(35, 218);
    //df::InputData in = df::make_random_input(40, 40);
    //df::InputData in = df::make_random_input(50, 40);


    // these are valid inputs where the algorithm with complicated conforming insertion check stucks BUT works if we do simple conforming check only:
    //df::InputData in = df::make_random_input(21, 44); 

    // -> the order of vertex insertions matters for the algorithm to succeed
    // -> sorting vertices by descending height is not correct 
    // what is the 'correct' order of vertex insertions?

    
    //viz::show_four_meshes(in);
    //viz::show_or_update_current(in);


    while (true) {

        // perform all conforming down-flips for the current triangulation until flip list is empty
        df::perform_all_conforming_down_flips(in);

        // see which vertices of the lower triangulation are still missing
        auto missing = df::find_missing_vertices(in.tri_current, in.tri_lower);


        if (missing.empty()) { 
            std::cout << "\n=== no missing vertices left ===\n";
            break; 
        }

        // print missing vertex ids in current triangulation
        std::cout << "\nMissing vertices (global ids): ";
        for (auto id : missing) std::cout << id << " ";
        std::cout << "\n";

        // pick candidates sorted by height (highest first)
        //std::vector<df::vertex_id> insertion_vertex_list =
        //df::sorted_insertion_vertices(missing, in);  // global ids sorted by height

        std::vector<df::vertex_id> insertion_vertex_list = missing; // unsorted version


        df::vertex_id insertion_vertex = 0; // will only be used if we find a conforming one
        bool found_conforming = false;

        // try candidates in order until one is BOTH a downflip and conforming
        for (auto id : insertion_vertex_list) {

            // 1) check downflip condition
            if (!df::is_insertion_downflip(id, in)) {
                std::cout << "[main] skipping vertex " << id
                        << " (insertion is not a down-flip)\n";
                continue;
            }

        
            // 2) check global conformance w.r.t. lower triangulation
            if (df::reg::is_insertion_conforming(id, in)) {
                insertion_vertex = id;
                found_conforming = true;
                break;
            } else {
                std::cout << "[main] WARNING: insertion of vertex " << id
                        << " is non-conforming, trying next candidate\n";
            }
        }

        // if no conforming insertion exists â†’ polyhedron is non-decomposable
        if (!found_conforming) {
            std::cout << "\n[main] ERROR: all candidate vertex insertions are non-conforming.\n"
                    << "[main] The polyhedron appears to be non-decomposable.\n";
            break;  // break out of the main while(true) loop
        }

        std::cout << "Inserting vertex (global id) " << insertion_vertex << "\n";
        df::apply_vertex_insertion(insertion_vertex, in);

        //viz::show_or_update_current(in);
        df::debug_print_edge_list(in);
    }
    
    // compare triangulations now 
    if (df::edge_diff_with_lower(in) == true){
        std::cout << "\n[main] ERROR: after all flips and insertions, current triangulation differs from lower triangulation!\n";
    } else {
        std::cout << "\n[main] SUCCESS: current triangulation matches lower triangulation!\n";
    }

    df::debug_print_local_to_global_map(in, df::TriKind::Lower);
    df::debug_print_local_to_global_map(in, df::TriKind::Current);
    df::print_step_history(in);


    // initialize replay
    std::cout << "Initializing replay...\n";

    // start replay triangulation as upper hull
    in.tri_replay = in.tri_upper;

    // initial replay visualization
    viz::show_or_update_replay(in);

    // show upper and lower triangulations as reference
    viz::show_four_meshes(in);

    replay_step = 0;
    replay_initialized = true;

    std::cout << "[replay] ready: " << in.step_history.size()
            << " recorded steps.\n";


    polyscope::state::userCallback = [&]() {

        if (!replay_initialized) return;

        ImGui::Begin("replay controls");

        int total = (int)in.step_history.size();
        ImGui::Text("step %d / %d", replay_step, total);

        if (ImGui::Button("reset")) {
            replay_step = 0;
            in.tri_replay = in.tri_upper;
            viz::show_or_update_replay(in);
        }

        if (ImGui::Button("next step")) {
            if (replay_step < total) {
                df::apply_step(in.step_history[replay_step], in);
                replay_step++;
            }
        }

        ImGui::End();
    };

    polyscope::show();
    return 0;
}




 





#include "conforming_insertion.h"
#include <CGAL/Segment_3.h>
#include <CGAL/Segment_2.h>
#include <CGAL/intersections.h>
#include <CGAL/Object.h>
#include <algorithm>
#include <limits>
#include <optional>
#include <variant>
#include <vector>
#include <iostream>
#include <unordered_map>

namespace df { namespace reg {

using K   = df::K;
using P2  = df::P2;
using P3  = df::P3;
using Tri = df::Tri2;
using Seg3 = CGAL::Segment_3<K>;
using Seg2 = CGAL::Segment_2<K>;



static inline P3 lift(const P2& p) {
    return P3(p.x(), p.y(), p.x()*p.x() + p.y()*p.y());
}


bool is_insertion_conforming(df::vertex_id id,
                             const df::InputData& D)
{
    const Tri& current = D.tri_current;
    const Tri& lower   = D.tri_lower;

    // 2D position of the vertex to be inserted
    const P2& d2 = D.points2d[id];
    P3        d3 = lift(d2);

    // locate in current triangulation
    Tri::Locate_type lt;
    int li; // index used if point lies on an edge
    Tri::Face_handle fh = current.locate(d2, lt, li);

    if (lt != Tri::FACE) {
        std::cout << "[conform] WARNING: insertion point is not inside a face, cannot check conforming\n";
        return false;
    }

    // face containing the point to be inserted
    auto va = fh->vertex(0);
    auto vb = fh->vertex(1);
    auto vc = fh->vertex(2);


    df::vertex_id ia = va->info();
    df::vertex_id ib = vb->info();
    df::vertex_id ic = vc->info();


    const P2& a2 = va->point();
    const P2& b2 = vb->point();
    const P2& c2 = vc->point();

    // fast path: are (a,d), (b,d), (c,d) already in the lower triangulation?
    bool ad_in_lower = false;
    bool bd_in_lower = false;
    bool cd_in_lower = false;

    for (auto e = lower.finite_edges_begin();
         e != lower.finite_edges_end(); ++e)
    {
        auto f  = e->first;
        int  ei = e->second;

        auto vu = f->vertex(lower.cw(ei));
        auto vv = f->vertex(lower.ccw(ei));

        df::vertex_id u = vu->info();
        df::vertex_id v = vv->info();

        if ((u == ia && v == id) || (u == id && v == ia))
            ad_in_lower = true;
        if ((u == ib && v == id) || (u == id && v == ib))
            bd_in_lower = true;
        if ((u == ic && v == id) || (u == id && v == ic))
            cd_in_lower = true;
    }

    if (ad_in_lower && bd_in_lower && cd_in_lower) {
        std::cout << "[conform] all three edges (" << ia << "," << id << "), ("
                  << ib << "," << id << "), (" << ic << "," << id
                  << ") are already in lower triangulation -> insertion is conforming\n";
        return true;
    }
return false;
}
}}